# 代理实验：编写一个缓存Web代理
15-213，20XX年秋季  
代理实验：编写一个缓存Web代理  
发布日期：11月19日，星期四  
**截止日期：12月8日，星期二，晚上11:59**  
最晚提交时间：12月11日，星期五，晚上11:59  

---  

### 1 简介  

Web代理是一个介于Web浏览器和*终端服务器*之间的中间程序。浏览器不直接联系终端服务器获取网页，而是联系代理，代理将请求转发给终端服务器。当终端服务器向代理回复时，代理再将回复转发给浏览器。  

代理有多种用途。有时代理用于防火墙中，使得防火墙后的浏览器只能通过代理联系防火墙外的服务器。代理还可以作为匿名器：通过剥离请求中的所有标识信息，代理可以使浏览器对Web服务器匿名。代理甚至可以通过存储服务器对象的本地副本来缓存Web对象，然后在未来的请求中直接从缓存中读取这些对象，而无需再次与远程服务器通信。  

在本实验中，你将编写一个简单的HTTP代理，用于缓存Web对象。实验的第一部分，你需要设置代理以接受传入连接，读取并解析请求，将请求转发到Web服务器，读取服务器的响应，并将这些响应转发给相应的客户端。这部分内容将涉及基本的HTTP操作以及如何使用套接字编写网络通信程序。第二部分，你需要升级代理以处理多个并发连接。这将让你接触到并发处理这一关键的系统概念。第三部分也是最后一部分，你将通过使用一个简单的内存缓存来存储最近访问的Web内容，为代理添加缓存功能。  

---  

### 2 实验安排  

这是一个个人项目。  

  
  

## 3 实验材料说明  

**站点特定说明：在此插入一段文字，说明教师如何将proxylab-handout.tar文件分发给学生。**  

将实验材料文件复制到计划工作的Linux机器上的受保护目录中，然后运行以下命令：  

linux> tar xvf proxylab-handout.tar  

这将生成一个名为proxylab-handout的目录。README文件描述了其中的各个文件。  

## 4 第一部分：实现一个顺序Web代理  

第一步是实现一个基本的顺序代理，处理HTTP/1.0的GET请求。其他请求类型（如POST）是可选的。  

启动时，代理应在命令行指定的端口上监听传入连接。一旦建立连接，代理应从客户端读取完整的请求并解析。它需要确定客户端是否发送了有效的HTTP请求；如果是，则可以建立与适当Web服务器的连接，并请求客户端指定的对象。最后，代理应读取服务器的响应并将其转发给客户端。  

### HTTP/1.0 GET请求  

当终端用户在Web浏览器的地址栏中输入类似http://www.cmu.edu/hub/index.html的URL时，浏览器会向代理发送一个HTTP请求，其起始行可能如下：  

GET http://www.cmu.edu/hub/index.html HTTP/1.1  

在这种情况下，代理应将请求解析为至少以下字段：主机名（www.cmu.edu）和路径或查询及其后的所有内容（/hub/index.html）。这样，代理可以确定它应该连接到www.cmu.edu，并发送自己的HTTP请求，起始行如下：  

GET /hub/index.html HTTP/1.0  

注意，HTTP请求中的所有行都以回车符'\r'和换行符'\n'结尾。同样重要的是，每个HTTP请求以一个空行"\r\n"结束。  

  

在上述示例中，你会注意到浏览器的请求行以HTTP/1.1结尾，而代理的请求行以HTTP/1.0结尾。现代浏览器会生成HTTP/1.1请求，但你的代理应处理这些请求并将其作为HTTP/1.0请求转发。  

需要注意的是，HTTP请求（即使是HTTP/1.0的GET请求子集）可能非常复杂。教科书描述了HTTP事务的某些细节，但你可以参考RFC 1945获取完整的HTTP/1.0规范。理想情况下，你的HTTP请求解析器应根据RFC 1945的相关部分完全健壮，但有一个例外：虽然规范允许多行请求字段，但你的代理不需要正确处理它们。当然，代理不应因格式错误的请求而提前终止。  

### 请求头  

本实验中重要的请求头包括Host、User-Agent、Connection和Proxy-Connection：  

* *始终发送Host头。虽然这种行为在技术上不符合HTTP/1.0规范，但对于某些Web服务器（尤其是使用虚拟主机的服务器）来说是必要的。Host头描述了终端服务器的主机名。例如，要访问http://www.cmu.edu/hub/index.html，代理应发送以下头：Host: www.cmu.edu。如果浏览器在其HTTP请求中附加了自己的Host头，代理应使用相同的Host头。  

* *你可以选择始终发送以下User-Agent头：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3。该头在两行中显示是因为在文档中无法单行显示，但代理应将其作为单行发送。User-Agent头标识了客户端（如操作系统和浏览器等参数），Web服务器通常利用这些信息来调整返回的内容。发送此特定的User-Agent字符串可能会在简单的telnet测试中改善返回内容的多样性和质量。  

* *始终发送以下Connection头：Connection: close  

* *始终发送以下Proxy-Connection头：Proxy-Connection: close  

Connection和Proxy-Connection头用于指定在第一次请求/响应交换完成后是否保持连接。代理为每个请求建立新连接是完全可接受的（也是建议的）。将这些头的值设为close可以通知Web服务器代理打算在第一次请求/响应交换后关闭连接。  

为了方便，proxy.c中提供了上述User-Agent头的字符串常量。  

最后，如果浏览器在HTTP请求中发送了任何额外的请求头，代理应原样转发它们。  

### 端口号  

本实验中有两类重要的端口号：HTTP请求端口和代理的监听端口。  

HTTP请求端口是HTTP请求URL中的可选字段。例如，URL可能为http://www.cmu.edu:8080/hub/index.html，此时代理应连接到主机www.cmu.edu的8080端口，而不是默认的HTTP端口80。无论URL中是否包含端口号，代理都必须正常工作。  

监听端口是代理监听传入连接的端口。代理应接受一个命令行参数，指定其监听端口号。例如，以下命令让代理在端口15213上监听连接：  

linux> ./proxy 15213  

你可以选择任何非特权监听端口（大于1024且小于65536），只要它未被其他进程使用。由于每个代理必须使用唯一的监听端口，且多人可能同时在每台机器上工作，脚本port-for-user.pl可帮助你选择个人端口号。基于用户ID生成端口号：  

linux> ./port-for-user.pl droh  
droh: 45806  

port-for-user.pl返回的端口号p始终为偶数。因此，如果需要额外的端口号（例如用于Tiny服务器），可以安全地使用端口p和p+1。  

请不要随机选择端口，否则可能会干扰其他用户。  

  

## 5 第二部分：处理多个并发请求  

实现顺序代理后，应修改它以同时处理多个请求。实现并发服务器的最简单方法是为每个新连接请求生成一个新线程。其他设计也是可能的，例如教科书中12.5.5节描述的预线程化服务器。  

* *注意，线程应以分离模式运行以避免内存泄漏。  
* *教科书CS:APP3e中描述的open_clientfd和open_listenfd函数基于现代且协议无关的getaddrinfo函数，因此是线程安全的。  

## 6 第三部分：缓存Web对象  

实验的最后部分是为代理添加缓存功能，将最近使用的Web对象存储在内存中。HTTP实际上定义了一个相当复杂的模型，Web服务器可以指示其服务的对象应如何缓存，客户端可以指定缓存的使用方式。然而，你的代理将采用一种简化的方法。  

当代理从服务器接收到Web对象时，应在将对象传输给客户端的同时将其缓存在内存中。如果另一个客户端从同一服务器请求相同的对象，代理无需重新连接到服务器，只需重新发送缓存的对象即可。  

显然，如果代理缓存每个请求过的对象，将需要无限的内存。此外，由于某些Web对象比其他对象大，可能会出现一个巨型对象占用整个缓存的情况，导致其他对象无法缓存。为避免这些问题，代理应设置最大缓存大小和最大缓存对象大小。  

### 最大缓存大小  

代理的整个缓存应具有以下最大大小：  

MAX_CACHE_SIZE = 1 MiB  

计算缓存大小时，代理仅统计用于存储实际Web对象的字节数，忽略任何额外字节（包括元数据）。  

### 最大对象大小  

代理应仅缓存不超过以下最大大小的Web对象：  

MAX_OBJECT_SIZE = 100 KiB  

  

为了方便，proxy.c中提供了这两个大小限制的宏定义。  

实现正确缓存的最简单方法是为每个活动连接分配一个缓冲区，并在从服务器接收数据时累积数据。如果缓冲区大小超过最大对象大小，则可以丢弃缓冲区。如果在未超过最大对象大小的情况下读取完Web服务器的整个响应，则可以缓存该对象。使用此方案，代理用于Web对象的最大数据量为：  

MAX_CACHE_SIZE + T * MAX_OBJECT_SIZE  

其中T为最大活动连接数。  

### 缓存替换策略  

代理的缓存应采用近似最近最少使用（LRU）的替换策略。不必严格遵循LRU，但应尽可能接近。注意，读取和写入对象都算作使用对象。  

### 同步  

对缓存的访问必须是线程安全的，确保缓存访问无竞争条件可能是本部分实验中最有趣的内容。实际上，有一个特殊要求：多个线程必须能够同时从缓存中读取。当然，一次只允许一个线程写入缓存，但对读取的限制不应存在。  

因此，使用一个大的独占锁保护缓存访问是不可接受的解决方案。你可以考虑分区缓存、使用Pthreads读写锁或使用信号量实现自己的读写解决方案。无论如何，由于不需要严格实现LRU替换策略，你在支持多线程读取方面有一定的灵活性。  

## 7 评估  

本实验总分为70分：  

* *_BasicCorrectness_：40分，用于基本的代理功能（自动评分）  
* *_Concurrency_：15分，用于处理并发请求（自动评分）  
* *_Cache_：15分，用于实现缓存功能（自动评分）  

### 自动评分  

实验材料中包含一个自动评分脚本driver.sh，教师将使用它来评估_BasicCorrectness_、_Concurrency_和_Cache_的得分。在proxylab-handout目录中运行：  

linux> ./driver.sh  

  

必须在Linux机器上运行该脚本。  

### 健壮性  

与往常一样，你的程序必须能够处理错误甚至畸形或恶意输入。服务器通常是长时间运行的进程，Web代理也不例外。仔细思考长时间运行的进程应对不同类型错误的反应方式。对于许多类型的错误，代理立即退出显然是不合适的。  

健壮性还意味着其他要求，包括对段错误等错误情况的免疫，以及没有内存泄漏和文件描述符泄漏。  

## 8 测试与调试  

除了简单的自动评分脚本外，你将没有其他样例输入或测试程序来测试你的实现。你需要设计自己的测试用例，甚至可能需要自己的测试工具来帮助调试代码并确定何时实现正确。这在现实世界中是一项宝贵的技能，因为实际运行条件通常未知，参考解决方案也往往不可用。  

幸运的是，有许多工具可用于调试和测试代理。务必测试所有代码路径和代表性输入，包括基本情况、典型情况和边缘情况。  

### Tiny Web服务器  

实验材料目录中包含CS:APP Tiny Web服务器的源代码。虽然不如thttpd强大，但CS:APP Tiny Web服务器易于修改，也是代理代码的合理起点。它还是驱动程序用于获取页面的服务器。  

### telnet  

如教科书（11.5.3节）所述，你可以使用telnet连接到代理并发送HTTP请求。  

### curl  

你可以使用curl向任何服务器（包括你自己的代理）生成HTTP请求。这是一个非常有用的调试工具。例如，如果代理和Tiny都在本地机器上运行，Tiny监听端口15213，代理监听端口15214，则可以通过以下curl命令通过代理请求Tiny的页面：  

linux> curl -v --proxy http://localhost:15214 http://localhost:15213/home.html  
* About to connect() to proxy localhost port 15214 (#0)  
* Trying 127.0.0.1... connected  

  

* Connected to localhost (127.0.0.1) port 15214 (#0)  
> GET http://localhost:15213/home.html HTTP/1.1  
> User-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu)...  
> Host: localhost:15213  
> Accept: */*  
> Proxy-Connection: Keep-Alive  
>  
* HTTP 1.0, assume close after body  
< HTTP/1.0 200 OK  
< Server: Tiny Web Server  
< Content-length: 120  
< Content-type: text/html  
<  
<html>  
<head><title>test</title></head>  
<body>  
<img align="middle" src="godzilla.gif">  
Dave O'Hallaron  
</body>  
</html>  
* Closing connection #0  

### netcat  

netcat（也称为nc）是一个多功能网络工具。你可以像telnet一样使用netcat连接到服务器。因此，假设代理在catshark上运行并监听端口12345，你可以通过以下方式手动测试代理：  

sh> nc catshark.ics.cs.cmu.edu 12345  
GET http://www.cmu.edu/hub/index.html HTTP/1.0  

HTTP/1.1 200 OK  
...  

除了连接到Web服务器外，netcat还可以作为服务器运行。以下命令让netcat作为服务器监听端口12345：  

sh> nc -l 12345  

设置netcat服务器后，你可以通过代理向其请求一个虚拟对象，并检查代理发送给netcat的完整请求。  

### Web浏览器  

最终，你应使用最新版本的Mozilla Firefox测试代理。访问About Firefox将自动更新浏览器到最新版本。  

要配置Firefox以使用代理，访问：  

Preferences>Advanced>Network>Settings  

通过真实的Web浏览器看到代理工作会非常令人兴奋。尽管代理的功能有限，但你会注意到可以通过代理浏览绝大多数网站。  

需要注意的是，使用Web浏览器测试缓存时必须非常小心。所有现代Web浏览器都有自己的缓存，测试代理缓存前应禁用这些缓存。  

## 9 提交说明  

提供的Makefile包含构建最终提交文件的功能。在工作目录中运行以下命令：  

linux> make handin  

输出文件为../proxylab-handin.tar，你可以提交该文件。  

**站点特定说明：在此插入一段文字，说明学生如何提交其proxylab-handin.tar解决方案文件。**  

* *教科书第10-12章包含有关系统级I/O、网络编程、HTTP协议和并发编程的有用信息。  
* *RFC 1945（http://www.ietf.org/rfc/rfc1945.txt）是HTTP/1.0协议的完整规范。  

## 10 提示  

* *如教科书10.11节所述，对套接字输入和输出使用标准I/O函数是有问题的。相反，建议使用Robust I/O（RIO）包，实验材料目录中的csapp.c文件提供了该包。  
* *csapp.c中提供的错误处理函数不适用于代理，因为服务器开始接受连接后不应终止。你需要修改它们或编写自己的函数。  
* *你可以自由修改实验材料目录中的文件。例如，出于良好的模块化考虑，你可以将缓存函数实现为cache.c和cache.h中的库。当然，添加新文件需要更新提供的Makefile。  

  

* *如CS:APP3e教科书第964页旁注所述，代理必须忽略SIGPIPE信号，并应优雅处理返回EPIPE错误的写操作。  
* *有时，从提前关闭的套接字读取字节会导致read返回-1且errno设置为ECONNRESET。代理不应因此错误而终止。  
* *记住，并非所有Web内容都是ASCII文本。许多Web内容是二进制数据（如图像和视频）。在选择和使用网络I/O函数时，确保考虑二进制数据。  
* *即使原始请求是HTTP/1.1，也应将所有请求作为HTTP/1.0转发。  

祝你好运！  

# 使用openssl以支持HTTPS的流程


### ✅ 1. `SSL_library_init();`

🔧 **作用**：初始化 OpenSSL 库中用于 SSL 的算法支持。

🔍 **背后干了什么**：

* 注册所有可用的加密算法（对称加密、哈希函数、RSA 等）。
* 在早期 OpenSSL 版本中这是必需的（从 OpenSSL 1.1.0 开始已废弃，因为库自己会初始化）。
* 没有这个函数你在低版本中无法使用 SSL/TLS 功能。


### ✅ 2. `SSL_load_error_strings();`

🔧 **作用**：加载用于错误信息的字符串描述。

🔍 **背后干了什么**：

* 加载所有 OpenSSL 内部的错误代码对应的可读字符串信息。
* 否则你调用 `ERR_print_errors_fp(stderr)` 打印出来的只有数字而非字符串错误描述。


### ✅ 3. `const SSL_METHOD *method = TLS_client_method();`

🔧 **作用**：返回一个适用于客户端连接的通用 TLS 方法结构体指针。

🔍 **背后干了什么**：

* `TLS_client_method()` 会自动协商支持的最高版本的 TLS（如 TLS 1.3）。
* `SSL_METHOD` 是一种“策略模板”，决定了连接的行为（协议版本、握手流程等）。
* 不同版本你可以指定 `TLSv1_2_client_method()` 等。


### ✅ 4. `SSL_CTX *ctx = SSL_CTX_new(method);`

🔧 **作用**：创建一个 SSL “上下文环境”（Context），用于配置和生成多个 SSL 会话。

🔍 **背后干了什么**：

* 创建一个结构体 `SSL_CTX`：

  * 包括证书验证策略
  * 可用加密算法
  * 默认选项（是否启用压缩、会话重用等）
* 它是所有 SSL 会话的“母体”。
* 你可以认为这是一个全局配置对象，一个 `SSL_CTX` 可用于多个连接。


### ✅ 5. `SSL *ssl = SSL_new(ctx);`

🔧 **作用**：为每一个连接创建一个新的 SSL 对象（即一个“会话”对象）。

🔍 **背后干了什么**：

* 创建 `SSL` 结构体：

  * 包含当前连接状态
  * 加密上下文
  * 协议状态（握手、数据传输等）
  * 使用 `ctx` 作为模板初始化
* 每个 TCP 连接对应一个 `SSL` 实例。


### ✅ 6. `SSL_set_fd(ssl, sockfd);`

🔧 **作用**：把一个 TCP socket 绑定到 SSL 对象中。

🔍 **背后干了什么**：

* 告诉 `SSL` 对象：你要在哪个 socket 文件描述符上进行 TLS 通信。
* `SSL` 内部会将这个 fd 存起来，之后所有 `SSL_read()`、`SSL_write()` 都会用这个 fd 来传输数据。


### ✅ 7. `SSL_free(ssl);`

🔧 **作用**：释放 SSL 会话对象及其关联资源。

🔍 **背后干了什么**：

* 清除所有连接状态和缓冲区
* 如果连接未关闭（没有调用 `SSL_shutdown()`），它也会尝试发送 `close_notify` 警告。
* 释放内部加密结构、BIO 缓冲区等。


### ✅ 8. `SSL_CTX_free(ctx);`

🔧 **作用**：释放 SSL 上下文对象。

🔍 **背后干了什么**：

* 释放所有关联的配置信息（加密算法、默认选项、证书验证路径等）。
* 如果你用了证书（比如 `SSL_CTX_use_certificate_file()`），也会被释放。



### ✅ 总结图示

```
TLS_client_method()      → 返回通信协议“模板”
    ↓
SSL_CTX_new(method)      → 创建上下文“工厂”，用于配置
    ↓
SSL_new(ctx)             → 为每个连接创建独立的 SSL 会话
    ↓
SSL_set_fd(ssl, sockfd)  → 绑定 socket 到 SSL 会话
    ↓
SSL_connect(ssl)         → 开始 TLS 握手
    ↓
SSL_read/SSL_write       → 发送/接收加密数据
    ↓
SSL_free(ssl)            → 清理会话
SSL_CTX_free(ctx)        → 清理上下文
```

